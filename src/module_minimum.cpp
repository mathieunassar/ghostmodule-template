/*
 * Copyright 2019 Mathieu Nassar
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <ghost/module/ModuleBuilder.hpp>
#include <ghost/module/Module.hpp>
#include <ghost/module/StdoutLogger.hpp>

 /***************************
	 TRY IT: Run this program. Observe the outputs generated by the initalize
	 and run methods.
 ***************************/

// This class contains the actual implementation of this program
class MyModule
{
public:
	// This method will be provided to the module builder as the "initialization method" of the program
	bool initialize(const ghost::Module& module)
	{
		// Among other things, the logger and the name of this module are reachable from these methods
		GHOST_INFO(module.getLogger()) << "This is module " << module.getModuleName();
		return true; // The initialization was successful, we can return true.
	}

	// This method will be called cyclically after we provide it to the module builder, until it returns false.
	bool run(const ghost::Module& module)
	{
		GHOST_INFO(module.getLogger()) << "This is a cycle.";
		return false; // We only want one cycle in this example. Otherwise, we would return true.
	}
};

int main()
{
	MyModule myModule;

	// Configuration of the module. We provide here all the components to the builder.
	auto builder = ghost::ModuleBuilder::create();
	// This line will provide the intialization method.
	builder->setInitializeBehavior(std::bind(&MyModule::initialize, &myModule, std::placeholders::_1));
	// This line will provide the run method, which will be called cyclically.
	builder->setRunningBehavior(std::bind(&MyModule::run, &myModule, std::placeholders::_1));
	// Since we want to use the logger, we provide one to the builder. More options are available here.
	builder->setLogger(ghost::StdoutLogger::create());
	
	// The following line creates the module with all the parameters, and names it "myModuleInstance0".
	std::shared_ptr<ghost::Module> module = builder->build("myModuleInstance0");
	// If the build process is successful, we can start the module. If it were not successful, we would have nullptr here.
	if (module)
		module->start();

	// Start blocks until the module ends.
	return 0;
}
